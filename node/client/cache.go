package node

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/hex"
	"encoding/pem"
	"fmt"
	"math/big"
	mathRand "math/rand"
	"os"
	"time"

	"github.com/dgrijalva/jwt-go"
)

/*
The cache is a special attribute of the Client.

Indeed, the cache is the abstraction from a collection of computations that generate
a new pair of credentials. Those credentials are used by the client to authenticate
its actions in the node.

No action can be performed without this authentication level. The authentication is based
on a token exchange. When the client provides the default credentials (alias and password),
the node can exhange it by the authorization token, that must be provided  by the client
instead the default credentials pair.

Note that the token is a encoded representation of the computed credentials that is going to be stored
in the cache, as much in-memory as in backlog. This method grants the client needs to refresh the credentials
whenever the credentials turn on expired.

The cache is ever been stored in a index of the node backlog.
*/
type Cache struct {
	ComputedKeyA string `json:"computed_key_a"` // A key generated by random computations above the account id
	ComputedKeyP string `json:"computed_key_p"` // A key generated by random computations above the password hash
	Timestamp    int64  `json:"timestamp"`      // The timestamp when the credentials were computed
	Alias        string `json:"-"`              // Alias from the client
	Password     string `json:"-"`              // Password hex hash from the client
	PublicKey    []byte `json:"-"`              // RSA public key
}

// Creates a encoded and encrypted representation of the cached credentials
func (c Cache) Token() (string, error) {
	block, _ := pem.Decode(c.PublicKey)
	if block == nil {
		return "", fmt.Errorf("falha ao decodificar a chave pública")
	}

	pubKeyInterface, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		return "", err
	}

	pubKey, ok := pubKeyInterface.(*rsa.PublicKey)
	if !ok {
		return "", fmt.Errorf("não é uma chave pública RSA válida")
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"data": map[string]interface{}{
			"computed_key_a": c.ComputedKeyA,
			"computed_key_p": c.ComputedKeyP,
			"timestamp":      c.Timestamp,
			"alias":          c.Alias,
			"password":       c.Password,
		},
	})

	jwtToken, err := token.SignedString([]byte(os.Getenv("SECRET")))
	if err != nil {
		return "", err
	}

	encryptedToken, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, pubKey, []byte(jwtToken), nil)
	if err != nil {
		return "", err
	}

	encryptedTokenStr := base64.StdEncoding.EncodeToString(encryptedToken)
	return encryptedTokenStr, nil
}

// Uses the crypto to decode and decrypt some given token
func (c CryptoResource) DecryptToken(encrypted string) (map[string]interface{}, error) {
	encryptedToken, err := base64.StdEncoding.DecodeString(encrypted)
	if err != nil {
		return nil, fmt.Errorf("failed do decode string: %v", err)
	}

	block, _ := pem.Decode(c.ImpersonatePrivateKey())

	if block == nil {
		return nil, fmt.Errorf("failed to decode private key bytes: %v", err)
	}

	privKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)

	if err != nil {
		return nil, fmt.Errorf("failed to parse private key: %v", err)
	}

	jwtTokenBytes, err := rsa.DecryptOAEP(sha256.New(), rand.Reader, privKey, encryptedToken, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to decrypt the token with the private key: %v", err)
	}

	token, err := jwt.Parse(string(jwtTokenBytes), func(decrypted *jwt.Token) (interface{}, error) {
		return []byte(os.Getenv("SECRET")), nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to parse token: %v", err)
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok || !token.Valid {
		return nil, fmt.Errorf("failed to claim the token: %v", err)
	}

	data, ok := claims["data"].(map[string]interface{})

	if !ok {
		return nil, fmt.Errorf("failed to convert token data... maybe it's corrupted: %v", err)
	}

	return data, nil
}

// Computes the first key of credentials based on the account id
func GenerateComputedKeyA(accountIDStr string) string {
	accountID, ok := new(big.Int).SetString(accountIDStr, 10)
	if !ok {
		return ""
	}

	mathRand.Seed(time.Now().UnixNano())

	for i := 0; i < 100; i++ {
		exponent := mathRand.Float64() + 1.0
		result := new(big.Float).SetInt(accountID)
		result = result.Mul(result, big.NewFloat(exponent))
		resultInt, _ := result.Int(nil)

		resultStr := resultInt.Text(10)
		var seed, complement *big.Int
		if len(resultStr) > 150 {
			seed, _ = new(big.Int).SetString(resultStr[:150], 10)
			complement, _ = new(big.Int).SetString(resultStr[150:], 10)
		} else {
			seed = resultInt
			complement = big.NewInt(0)
		}

		accountID = new(big.Int).Add(seed, complement)
	}

	hash := sha256.Sum256([]byte(accountID.Text(10)))
	return hex.EncodeToString(hash[:])
}

// Computes the second key of credentials based on the password hash
func GenerateComputedKeyP(pwdHashInt int64) string {
	pwdHash := big.NewInt(pwdHashInt)
	pwdHash.Abs(pwdHash)

	mathRand.Seed(time.Now().UnixNano())

	for i := 0; i < 100; i++ {
		exponent := mathRand.Float64() + 1.0
		result := new(big.Float).SetInt(pwdHash)
		result = result.Mul(result, big.NewFloat(exponent))
		resultInt, _ := result.Int(nil)

		resultStr := resultInt.Text(10)
		var seed, complement *big.Int
		if len(resultStr) > 150 {
			seed, _ = new(big.Int).SetString(resultStr[:150], 10)
			complement, _ = new(big.Int).SetString(resultStr[150:], 10)
		} else {
			seed = resultInt
			complement = big.NewInt(0)
		}

		pwdHash = new(big.Int).Add(seed, complement)
	}

	hash := sha256.Sum256([]byte(pwdHash.Text(10)))
	return hex.EncodeToString(hash[:])
}
